# abc6b.R - DESC
# /home/mosquia/Active/Doing/ABC_tuna+iotc/abc_tuna/v2/abc.R
# resample (h,M) from joint distribution
# resample sigmaR using informative conjugate prior

# Copyright (c) WUR, 2023.
# Author: Iago MOSQUEIRA (WMR) <iago.mosqueira@wur.nl>
#
# Distributed under the terms of the EUPL-1.2


# data

#' @param laa Length at ageby sex
#' @param wal Weight at length by sex
#' @param mal Maturity at length for females
#' @param cpues CPUE indices by fishery, area [fishery, year]
#' @param lenfreq Length-frequency in catch by fishery [len, year, fishery]
#' @param iALK, VB

# arguments

#' @param priors List for h, K
#' @param pvars Proposal variances
#' @param Fstatus F/FMSY prior

library(Rcpp)
library(FLCore)
library(ggplotFL)
library(parallel)
library(mvtnorm)
source("utilities.R")

sourceCpp("utilities/init_pdyn.cpp")
sourceCpp("utilities/msy_pdyn.cpp")
sourceCpp("utilities/pdyn_lfcpue.cpp")

# NC by fleet [y, s, f]
# 

#load('../data/data.RData')
load("data/alb_abcdata.rda")
load("data/hmuprior.rda")

# fnscale 
fnscale <- 1

# years and values for stock status priors

yof <- 1:ny # apply over-fishing prior penalty
sdof <- 0.5 # idea P(hmsyrat > 2) <= 0.05 essentially
ybmsy <- c(ny-1,ny)
mubmsy <- c(2.25,2)
sdbmsy <- c(0.35,0.35)
ydep <- 1
mudep <- 0.5
sddep <- 0.1

# rescale weight to tonnes

wta <- wta[]*1e-3
 
pobs <- apply(LFfits,2,function(x){x <- x/sum(x)}) # what we will fit to

# --- simulator

# - arguments
#   - parameters: R0, dep, h, epsr, selpars
#   - biology
#   - fishery

R0 <- 14e6
dep <- 0.5
h <- 0.8

# number of fisheries

nf <- dim(C)[3]

# number of distinct selectivity groups

nselg <- 5

# selectivity for each fishery

selidx <- c(1,2,3,4,5,5)

# fisheries with LF data

flf <- c(1,2,3,4,6)
nflf <- length(flf)
pobs <- apply(LFfits,2,function(x){x <- x/sum(x)}) # what we will fit to
pobs <- pobs[,flf]

# catch distro targets

pctarg <- C[1,,] / sum(C[1,,])

# set up selectivity parameters (all double normal)

smax <- c(120,125,85,85,115)
sL <- c(20,20,7,7,10)
sR <- c(35,30,25,15,30)
selpars <- cbind(smax,sL,sR)

# recruitment variations (ny-1)

epsr <- rep(0,ny-1)

# informative priors (roughly between 0.2-0.5 mean of 0.3)

musigma2R <- 0.3^2
cvx <- 0.4
mux <- 1/musigma2R
vx <- (mux*cvx)^2
alpR <- mux^2/vx
betR <- mux/vx
psigmaR <- sqrt(1/rgamma(1000,alpR,betR))
round(quantile(psigmaR,c(0.025,0.5,0.975)),2)

# recruitment season

srec <- 4

# sex ratio at birth (fiddy:fiddy)

psi <- 0.5

# dimensions

dms <- c(na,ns,nf,nselg)

## MCMC algorithm 

# set up MCMC controls for unconditional sampling of (h,M)

acphmu <- 0.25 # force acceptance rate at "optimal" MCMC value

# Gibbs sampling parameter groupings
# 1. B0 and dep
# 2. recruitment deviates
# 3. selectivity 

npar <- 2+ny-1+3*nselg
ngibbs <- 3
paridx <- list()
paridx[[1]] <- 1:2
paridx[[2]] <- 3:(ny+1)
paridx[[3]] <- (ny+2):npar
lidx <- unlist(lapply(paridx,length))

# SD in CPUE index

fcpue <- 1
scpue <- 1:4
sd.cpue <- rep(NA,length(scpue))

sdcpue <- mean(sd.cpue)

# KLmax

KLmax <- 0.8 # consistent with minimum Neff = 20 multinomial

# seasonal q for CPUE (T or F)

seasonq <- TRUE

# catchability trend: 1% p.a.

qtrend <- TRUE
delq <- 0.01
qt <- exp(delq*(0:(ny-1))) %o% rep(1,4)


# burn-in and thinning factor
 
burn <- 10
thin <- 1

###################
# run the sampler #
###################

# set up initial h and M

hold <- hmu
Mold <- Mmu
sigmarold <- sqrt(musigma2R)

# set up initial guess parameter vector

parvecold <- c(log(R0),logit(dep),epsr,log(as.vector(selpars)))

# RW variance by Gibbs grouping

rwsd <- rep(0,npar)
rwsd[paridx[[1]]] <- c(0.1,0.05)
rwsd[paridx[[2]]] <- 0.08
rwsd[paridx[[3]]] <- 0.025

nits1 <- 10 # total number of retained samples
system.time(zzz <- mcmc5.abc(nits1))
zzz$acp/nits1

# parallelised efficient version

parvecold <- zzz$pars[nits1,1:npar]
hold <- zzz$pars[nits1,npar+1]
Mold <- zzz$pars[nits1,npar+2]
sigmarold <- zzz$pars[nits1,npar+3]
nits <- 500
ncore <- 5
thin <- 100
mcnits <- floor(nits/ncore)
system.time(mczzz <- mclapply(rep(mcnits,ncore),mcmc5.abc,mc.cores=ncore))

# EXTRACT
mcpars <- do.call(rbind, lapply(mczzz, '[[', 'pars'))
mcvars <- get.mcmc2.vars(mcpars)

# SAVE
save(mczzz, file="data/mcmc/abc6b.rda", compress="xz")
save(mcvars, C, file="data/mcvars/abc6b.rda", compress="xz")

#
load("data/base.rda")

# EXTRACT output for all iters
out <- mc.output(mcvars, C)

# --- CREATE om {{{

its <- dims(out$m)$iter

# - FLBiol (stock.n, m)

bio <- propagate(window(sbio, start=2000), its)

n(bio) <- out$stock.n
m(bio) <- out$m

sr(bio) <- predictModel(model=bevholtss3()$model, params=out$srpars)

# spwn, mid Q4
spwn(bio)[,,,4] <- 0.5

# FIX mat BUG: CHECK readFLSss3 +ss3om 
mat(bio)[,,'F',1:4] <- mat(bio)[,,'F',1]

# TODO: DEVIANCES

deviances(bio)

# BUG:
predict(sr(bio), ssb=out$ssb)
seasonSums(unitSums(rec(bio)))

# - FLFisheries (catch.n, catch.sel)

# FLCatch(es)
cas <- Map(function(x, y) FLCatch(landings.n=x, landings.wt=wt(bio),
  catch.sel=y, discards.n=x %=% 0, discards.wt=wt(bio)),
  x=divide(out$catch.n, 5), y=divide(out$catch.sel %*% (out$catch.n %=% 1), 5))

# FLFisheries
fis <- FLFisheries(lapply(cas, function(x)
  FLFishery(effort=unitSums(catch(cas[[1]])) %=% 0, ALB=x)))

names(fis) <- c(paste0("LL", 1:4), "PS", "Other")

# PLOT
plot(fis)

om <- FLombf(biols=FLBiols(ALB=bio), fisheries=fis,
  refpts=FLPars(ALB=out$refpts))

# ADD hr
# TODO: SET harvest as slot
attr(om, 'harvest') <- FLQuants(ALB=expand(n(biol(om)), area=1:6) %=% as.numeric(NA))

# TEST om


# - BUILD oem

# idx: FLIndexBiomass by season, with sel.pattern by sex

NW <- FLIndexBiomass(index=out$index.hat %*% out$index.q,
  index.q=expand(out$index.q, year=2000:2020),
  sel.pattern=expand(out$sel, year=2000:2020),
  catch.wt=wt(biol(om)),
  range=c(startf=0.5, endf=0.5))

# stk: no units
oem <- FLoem(
    observations=list(ALB=list(idx=FLIndices(NW=NW),
      stk=simplify(stock(om)[[1]], 'unit'))),
    method=sampling.oem)

survey(observations(oem)$ALB$stk, observations(oem)$ALB$idx)

# TODO: verify(oem, om)

# SAVE
save(om, oem, file='data/omb6b.rda', compress='xz')

# }}}


##
mcacp <- apply(matrix(unlist(lapply(mczzz,function(x){x <- x$acp})),ncol=ngibbs,byrow=T),2,sum)/(nits*thin)
mcacp
mcpars <- mczzz[[1]]$pars
mcloo <- mczzz[[1]]$cpuelogl
for(i in 2:ncore) mcpars <- rbind(mcpars,mczzz[[i]]$pars)
for(i in 2:ncore) mcloo <- rbind(mcloo,mczzz[[i]]$cpuelogl)
boxplot(mcpars,outline=F,col='magenta') 

plot.mcmc.vars(mcvars,'dep')
plot.mcmc.vars(mcvars,'bmsy')
plot.mcmc.vars(mcvars,'hmsy')
plot.mcmc.vars(mcvars,'rec')
plot.mcmc.cpue(mcvars)
plot.mcmc.lf(mcvars)
plot.mcmc.sel(mcpars)

# prior vs posterior sigmaR

sigrpost <- mcpars[,npar+3]
dpost <- density(sigrpost)
dprior <- density(psigmaR)
p1 <- dpost$y
p1 <- p1/sum(p1)
x1 <- dpost$x
p2 <- dprior$y
p2 <- p2/sum(p2)
x2 <- dprior$x
pmax <- max(c(max(p1),max(p2)))
xmin <- min(c(min(x1),min(x2)))
xmax <- max(c(max(x1),max(x2)))
plot(x1,p1,type='l',xlim=c(xmin,xmax),ylim=c(0,pmax),xlab=expression(sigma[R]),ylab='density')
lines(x2,p2,lty=2,col='purple')
legend("topright",lty=c(1,2),col=c("black","purple"),legend=c("Posterior","Prior"),bty='n')

######################
# variable summaries #
######################

# depletion (2000, 2020)

varz <- matrix(nrow=nits,ncol=length(mcvars[[1]]$dep))
for(nn in 1:nits) varz[nn,] <- mcvars[[nn]]$dep
round(apply(varz[,c(1,21)],2,quantile,c(0.025,0.5,0.975)),2)

# Bmsy ratio (2020)

varz <- matrix(nrow=nits,ncol=length(mcvars[[1]]$dbmsy))
for(nn in 1:nits) varz[nn,] <- mcvars[[nn]]$dbmsy
round(quantile(varz[,21],c(0.025,0.5,0.975)),2)

# Hmsy ratio (2020)

varz <- matrix(nrow=nits,ncol=length(mcvars[[1]]$hmsyrat))
for(nn in 1:nits) varz[nn,] <- mcvars[[nn]]$hmsyrat
round(quantile(varz[,21],c(0.025,0.5,0.975)),2)

save.image("data/image/alb_abc_run6b.rda", compress="xz")

